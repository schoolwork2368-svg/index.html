<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Universal Image Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Include jsPDF for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
            color: #1f2937;
        }
        .slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #e0e7ff;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 4px;
        }
        .slider:hover {
            opacity: 1;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }
        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }
        .control-group {
            margin-bottom: 1.5rem;
            padding: 1rem;
            border-radius: 0.5rem;
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
        }
        #conversionCanvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: filter 0.3s ease-out; /* Smooth CSS filter transitions */
        }
    </style>
</head>
<body class="min-h-screen flex flex-col md:flex-row">

    <!-- Controls Sidebar -->
    <div id="controls-panel" class="w-full md:w-80 p-6 bg-white shadow-2xl overflow-y-auto border-r border-gray-200 flex-shrink-0">
        <h1 class="text-2xl font-bold mb-6 text-indigo-700">Image Editor</h1>
        
        <!-- Tab Navigation -->
        <div class="flex mb-4 border-b border-gray-200">
            <button id="tab-adjust" class="flex-1 py-2 text-sm font-medium border-b-2 border-indigo-600 text-indigo-600 transition duration-150">Adjust</button>
            <button id="tab-presets" class="flex-1 py-2 text-sm font-medium border-b-2 border-transparent text-gray-500 hover:text-indigo-600 hover:border-indigo-300 transition duration-150">Presets</button>
            <button id="tab-export" class="flex-1 py-2 text-sm font-medium border-b-2 border-transparent text-gray-500 hover:text-indigo-600 hover:border-indigo-300 transition duration-150">Export</button>
        </div>

        <!-- Adjustment Tab Content -->
        <div id="content-adjust" class="tab-content">
            <div class="control-group">
                <h2 class="font-semibold text-lg mb-4 text-gray-700">Image Adjustments</h2>
                
                <div class="mb-5">
                    <label class="block text-sm font-medium text-gray-700 flex justify-between">Brightness: <span id="brightnessValue" class="font-mono text-indigo-600">100%</span></label>
                    <input type="range" id="brightness" min="0" max="200" value="100" class="slider" data-unit="%">
                </div>

                <div class="mb-5">
                    <label class="block text-sm font-medium text-gray-700 flex justify-between">Contrast: <span id="contrastValue" class="font-mono text-indigo-600">100%</span></label>
                    <input type="range" id="contrast" min="0" max="200" value="100" class="slider" data-unit="%">
                </div>

                <div class="mb-5">
                    <label class="block text-sm font-medium text-gray-700 flex justify-between">Saturation: <span id="saturationValue" class="font-mono text-indigo-600">100%</span></label>
                    <input type="range" id="saturation" min="0" max="200" value="100" class="slider" data-unit="%">
                </div>
                
                <div class="mb-5">
                    <label class="block text-sm font-medium text-gray-700 flex justify-between">Hue: <span id="hueRotateValue" class="font-mono text-indigo-600">0°</span></label>
                    <input type="range" id="hueRotate" min="0" max="360" value="0" class="slider" data-unit="deg">
                </div>
            </div>
            
            <button id="resetButton" class="w-full bg-red-500 text-white font-bold py-2 rounded-lg hover:bg-red-600 transition duration-150 shadow-md">
                Reset All Edits
            </button>
        </div>

        <!-- Presets Tab Content -->
        <div id="content-presets" class="tab-content hidden">
            <div class="control-group">
                <h2 class="font-semibold text-lg mb-4 text-gray-700">Quick Filters</h2>
                
                <div class="space-y-3">
                    <label class="flex items-center space-x-3 cursor-pointer">
                        <input type="checkbox" id="grayscale" class="h-5 w-5 text-indigo-600 rounded border-gray-300 focus:ring-indigo-500">
                        <span class="text-gray-700">Grayscale (Black & White)</span>
                    </label>
                    <label class="flex items-center space-x-3 cursor-pointer">
                        <input type="checkbox" id="sepia" class="h-5 w-5 text-indigo-600 rounded border-gray-300 focus:ring-indigo-500">
                        <span class="text-gray-700">Sepia (Old Photo Look)</span>
                    </label>
                    <label class="flex items-center space-x-3 cursor-pointer">
                        <input type="checkbox" id="invert" class="h-5 w-5 text-indigo-600 rounded border-gray-300 focus:ring-indigo-500">
                        <span class="text-gray-700">Invert Colors (Negative)</span>
                    </label>
                </div>
            </div>
        </div>
        
        <!-- Export Tab Content (Original Converter Logic) -->
        <div id="content-export" class="tab-content hidden">
            <div class="control-group">
                <h2 class="font-semibold text-lg mb-4 text-gray-700">Export Options</h2>
                
                <div class="bg-yellow-50 border-l-4 border-yellow-400 p-3 mb-4 rounded-lg">
                    <p class="text-xs text-yellow-700">
                        Formats like TIFF, RAW, PSD, and EPS require proprietary software and cannot be generated in the browser.
                    </p>
                </div>

                <div class="mb-5">
                    <label for="outputFormat" class="block text-sm font-medium text-gray-700 mb-2">Select Output Format:</label>
                    <select id="outputFormat" class="w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 ease-in-out">
                        <option value="png" selected>PNG (Lossless)</option>
                        <option value="jpeg">JPG/JPEG (Lossy)</option>
                        <option value="pdf">PDF Document (Image on A4)</option>
                        <option value="svg">SVG (Simple Vector Art)</option>
                        <option value="ico">ICO (Windows Icon)</option>
                    </select>
                </div>

                <!-- ICO Size Control -->
                <div id="icoSizeControl" class="mb-5 hidden">
                    <label for="icoSize" class="block text-sm font-medium text-gray-700 mb-2">Icon Size (Square Pixels):</label>
                    <select id="icoSize" class="w-full p-3 border border-gray-300 rounded-lg shadow-sm">
                        <option value="32" selected>32 x 32 (Standard Favicon)</option>
                        <option value="16">16 x 16</option>
                        <option value="48">48 x 48</option>
                        <option value="64">64 x 64</option>
                    </select>
                </div>
                
                <div id="qualityControl" class="mb-5 hidden">
                    <label for="jpegQuality" class="block text-sm font-medium text-gray-700 mb-2 flex justify-between">
                        JPG Quality: <span id="qualityValue" class="font-mono text-indigo-600">90%</span>
                    </label>
                    <input type="range" id="jpegQuality" min="10" max="100" value="90" step="1" class="slider" data-unit="%">
                </div>
                
                <button id="convertButton" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg hover:bg-indigo-700 transition duration-150">
                    Export Image
                </button>
            </div>
        </div>
    </div>

    <!-- Main Editor Area -->
    <div id="editor-area" class="flex-1 flex flex-col p-6 items-center justify-center bg-gray-100">
        
        <!-- Top Toolbar -->
        <div class="w-full max-w-4xl flex justify-between items-center mb-4 bg-white p-3 rounded-lg shadow-md border border-gray-200">
             <div class="flex items-center space-x-3">
                <input type="file" id="fileInput" accept="image/png, image/jpeg" class="hidden" />
                <label for="fileInput" class="bg-indigo-500 text-white px-4 py-2 rounded-lg text-sm font-semibold cursor-pointer hover:bg-indigo-600 transition duration-150 shadow-md">
                    Load New Image
                </label>
                <span id="imageNameDisplay" class="text-sm text-gray-600 truncate max-w-xs italic">No image loaded</span>
            </div>
        </div>

        <!-- Canvas/Drop Zone -->
        <div id="drop-zone" class="w-full flex-1 max-w-4xl bg-gray-200 rounded-xl shadow-inner border-4 border-dashed border-gray-400 flex items-center justify-center overflow-hidden">
            <canvas id="conversionCanvas" class="hidden"></canvas>
            <div id="placeholder" class="text-center p-10 text-gray-600">
                <svg xmlns="http://www.w3.org/2000/svg" class="mx-auto h-16 w-16 text-gray-500 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 16m-9-9h.01M6 18h8a2 2 0 002-2V8a2 2 0 00-2-2H6a2 2 0 00-2 2v8a2 2 0 002 2z" />
                </svg>
                <p class="text-lg font-semibold">Drag & Drop an image here, or use 'Load New Image'.</p>
                <p class="text-sm mt-1">PNG or JPG supported.</p>
            </div>
        </div>
        <p id="message-box" class="mt-4 text-sm text-center text-red-500"></p>
    </div>
    
    <script>
        const { jsPDF } = window.jspdf;
        
        // --- DOM Elements ---
        const fileInput = document.getElementById('fileInput');
        const conversionCanvas = document.getElementById('conversionCanvas');
        const ctx = conversionCanvas.getContext('2d');
        const convertButton = document.getElementById('convertButton');
        const resetButton = document.getElementById('resetButton');
        const dropZone = document.getElementById('drop-zone');
        const placeholder = document.getElementById('placeholder');
        const imageNameDisplay = document.getElementById('imageNameDisplay');
        const outputFormat = document.getElementById('outputFormat');
        const qualityControl = document.getElementById('qualityControl');
        const icoSizeControl = document.getElementById('icoSizeControl');
        const sliders = {
            brightness: document.getElementById('brightness'),
            contrast: document.getElementById('contrast'),
            saturation: document.getElementById('saturation'),
            hueRotate: document.getElementById('hueRotate')
        };
        const checkboxes = {
            grayscale: document.getElementById('grayscale'),
            sepia: document.getElementById('sepia'),
            invert: document.getElementById('invert')
        };
        const tabs = {
            adjust: document.getElementById('tab-adjust'),
            presets: document.getElementById('tab-presets'),
            export: document.getElementById('tab-export')
        };
        const tabContents = {
            adjust: document.getElementById('content-adjust'),
            presets: document.getElementById('content-presets'),
            export: document.getElementById('content-export')
        };

        // --- State ---
        let originalImage = null;
        let originalFileName = 'edited_image';
        
        const defaultSettings = {
            brightness: 100, contrast: 100, saturation: 100, hueRotate: 0,
            grayscale: false, sepia: false, invert: false
        };
        let settings = {...defaultSettings};
        
        const SVG_BLOCK_SIZE = 5; 

        // --- Utility Functions ---

        function showMessage(type, text) {
            const box = document.getElementById('message-box');
            box.textContent = text;
            box.className = `mt-4 text-sm text-center font-semibold ${type === 'error' ? 'text-red-500' : 'text-green-600'}`;
            setTimeout(() => box.textContent = '', 4000);
        }

        // --- Core Editor Logic ---

        function redrawCanvas() {
            if (!originalImage) return;

            const { brightness, contrast, saturation, hueRotate, grayscale, sepia, invert } = settings;
            
            // Build the CSS filter string
            let filterString = `brightness(${brightness}%) contrast(${contrast}%) saturate(${saturation}%) hue-rotate(${hueRotate}deg)`;
            if (grayscale) filterString += ' grayscale(100%)';
            if (sepia) filterString += ' sepia(100%)';
            if (invert) filterString += ' invert(100%)';

            // Apply filter to the canvas context
            ctx.filter = filterString;
            
            // Clear and redraw the image
            ctx.clearRect(0, 0, conversionCanvas.width, conversionCanvas.height);
            ctx.drawImage(originalImage, 0, 0, conversionCanvas.width, conversionCanvas.height);
            
            // Apply filter to the canvas *style* for better visual preview (less useful than ctx.filter, but ensures fallback)
            conversionCanvas.style.filter = '';
        }

        function handleImageLoad(file) {
            if (!file || !file.type.startsWith('image/')) {
                showMessage('error', 'Please select a valid image file (PNG or JPG).');
                return;
            }
            if (file.size > 10 * 1024 * 1024) {
                 showMessage('error', 'File size exceeds the 10MB limit.');
                 return;
            }

            originalFileName = file.name.split('.').slice(0, -1).join('.') || 'edited_image';
            imageNameDisplay.textContent = file.name;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    
                    // Set canvas dimensions to image dimensions
                    conversionCanvas.width = img.naturalWidth;
                    conversionCanvas.height = img.naturalHeight;
                    
                    // Show canvas and hide placeholder
                    conversionCanvas.classList.remove('hidden');
                    placeholder.classList.add('hidden');
                    dropZone.classList.remove('border-dashed', 'border-gray-400');

                    // Reset all controls and settings
                    resetAllSettings();
                    
                    // Initial draw
                    redrawCanvas();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function resetAllSettings() {
            settings = {...defaultSettings};
            
            // Reset sliders
            sliders.brightness.value = defaultSettings.brightness;
            document.getElementById('brightnessValue').textContent = `${defaultSettings.brightness}%`;
            sliders.contrast.value = defaultSettings.contrast;
            document.getElementById('contrastValue').textContent = `${defaultSettings.contrast}%`;
            sliders.saturation.value = defaultSettings.saturation;
            document.getElementById('saturationValue').textContent = `${defaultSettings.saturation}%`;
            sliders.hueRotate.value = defaultSettings.hueRotate;
            document.getElementById('hueRotateValue').textContent = `${defaultSettings.hueRotate}°`;
            
            // Reset checkboxes
            checkboxes.grayscale.checked = defaultSettings.grayscale;
            checkboxes.sepia.checked = defaultSettings.sepia;
            checkboxes.invert.checked = defaultSettings.invert;

            redrawCanvas();
        }

        // --- Event Listeners for Editing Controls ---

        // Sliders
        Object.keys(sliders).forEach(key => {
            const slider = sliders[key];
            const display = document.getElementById(`${key}Value`);
            const unit = slider.getAttribute('data-unit');
            
            slider.addEventListener('input', () => {
                settings[key] = parseInt(slider.value);
                display.textContent = `${slider.value}${unit}`;
                redrawCanvas();
            });
        });

        // Checkboxes
        Object.keys(checkboxes).forEach(key => {
            const checkbox = checkboxes[key];
            checkbox.addEventListener('change', () => {
                settings[key] = checkbox.checked;
                redrawCanvas();
            });
        });
        
        // Reset Button
        resetButton.addEventListener('click', () => {
            if (originalImage) {
                resetAllSettings();
                showMessage('success', 'Edits have been reset.');
            }
        });

        // Tab Switching
        Object.keys(tabs).forEach(tabKey => {
            tabs[tabKey].addEventListener('click', () => {
                Object.keys(tabs).forEach(key => {
                    tabs[key].classList.remove('border-indigo-600', 'text-indigo-600');
                    tabs[key].classList.add('border-transparent', 'text-gray-500', 'hover:text-indigo-600', 'hover:border-indigo-300');
                    tabContents[key].classList.add('hidden');
                });
                
                tabs[tabKey].classList.add('border-indigo-600', 'text-indigo-600');
                tabs[tabKey].classList.remove('border-transparent', 'text-gray-500', 'hover:text-indigo-600', 'hover:border-indigo-300');
                tabContents[tabKey].classList.remove('hidden');
                
                // Toggle display controls for Export tab
                if (tabKey === 'export') {
                    handleFormatChange();
                }
            });
        });

        // --- File Input and Drag/Drop ---

        fileInput.addEventListener('change', (e) => {
            handleImageLoad(e.target.files[0]);
        });
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('border-indigo-500', 'bg-indigo-50');
        });

        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropZone.classList.remove('border-indigo-500', 'bg-indigo-50');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('border-indigo-500', 'bg-indigo-50');
            const file = e.dataTransfer.files[0];
            handleImageLoad(file);
        });
        
        // --- Export/Conversion Logic (Integrated) ---

        function handleFormatChange() {
            const format = outputFormat.value;
            qualityControl.classList.toggle('hidden', format !== 'jpeg');
            icoSizeControl.classList.toggle('hidden', format !== 'ico');
            
            // Update JPG quality display
            if (format === 'jpeg') {
                const jpegQuality = document.getElementById('jpegQuality');
                document.getElementById('qualityValue').textContent = `${jpegQuality.value}%`;
            }
        }
        
        outputFormat.addEventListener('change', handleFormatChange);
        
        // JPEG quality slider update
        document.getElementById('jpegQuality')?.addEventListener('input', () => {
            document.getElementById('qualityValue').textContent = `${document.getElementById('jpegQuality').value}%`;
        });

        // Binary Helper Functions for ICO
        function numToBuffer(num, bytes) {
            const arr = new ArrayBuffer(bytes);
            const view = new DataView(arr);
            if (bytes === 2) view.setUint16(0, num, true);
            else if (bytes === 4) view.setUint32(0, num, true);
            else view.setUint8(0, num);
            return arr;
        }
        function concatBuffers(buffers) {
            const totalLength = buffers.reduce((acc, buf) => acc + buf.byteLength, 0);
            const result = new Uint8Array(totalLength);
            let offset = 0;
            buffers.forEach(buf => {
                result.set(new Uint8Array(buf), offset);
                offset += buf.byteLength;
            });
            return result.buffer;
        }
        function readBlobAsArrayBuffer(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(blob);
            });
        }
        
        // SVG Logic
        function rasterToSimpleSVG(canvas, width, height) {
            let svg = `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">`;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const step = SVG_BLOCK_SIZE;

            for (let y = 0; y < height; y += step) {
                for (let x = 0; x < width; x += step) {
                    const index = (y * width + x) * 4;
                    const r = data[index];
                    const g = data[index + 1];
                    const b = data[index + 2];
                    const a = data[index + 3];

                    const hexColor = `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase().padStart(6, '0')}`;
                    const opacity = a / 255; 

                    if (opacity > 0) {
                       svg += `<rect x="${x}" y="${y}" width="${step}" height="${step}" fill="${hexColor}" fill-opacity="${opacity.toFixed(2)}" />`;
                    }
                }
            }
            svg += '</svg>';
            return svg;
        }
        
        // ICO Logic
        async function convertToICO(canvas) {
            const size = parseInt(document.getElementById('icoSize').value);
            
            // Use a temporary canvas for resizing the final output
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = size;
            tempCanvas.height = size;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, 0, 0, size, size); // Draw processed image onto temp canvas

            const pngBlob = await new Promise(resolve => tempCanvas.toBlob(resolve, 'image/png'));
            const pngArrayBuffer = await readBlobAsArrayBuffer(pngBlob);
            const pngDataLength = pngArrayBuffer.byteLength;
            const dataOffset = 6 + 16; 

            const iconDir = concatBuffers([
                numToBuffer(0, 2), numToBuffer(1, 2), numToBuffer(1, 2)
            ]);

            const iconDirEntry = concatBuffers([
                numToBuffer(size, 1), numToBuffer(size, 1), numToBuffer(0, 1), numToBuffer(0, 1),
                numToBuffer(1, 2), numToBuffer(32, 2), numToBuffer(pngDataLength, 4), numToBuffer(dataOffset, 4)
            ]);
            
            const icoBuffer = concatBuffers([iconDir, iconDirEntry, pngArrayBuffer]);
            return new Blob([icoBuffer], { type: 'image/x-icon' });
        }

        // PDF Logic
        async function convertToPDF(canvas, img) {
            // Standard A4 dimensions in points
            const doc = new jsPDF('portrait', 'pt', 'a4');
            const docWidth = doc.internal.pageSize.getWidth();
            const docHeight = doc.internal.pageSize.getHeight();
            
            const imgWidth = canvas.width;
            const imgHeight = canvas.height;
            const ratio = imgWidth / imgHeight;

            // Calculate dimensions to fit the page
            let width = docWidth;
            let height = docWidth / ratio;
            
            // If the calculated height is too large, resize based on height
            if (height > docHeight) {
                height = docHeight;
                width = docHeight * ratio;
            }

            // Center the image
            const x = (docWidth - width) / 2;
            const y = (docHeight - height) / 2;

            // Get the image data *after* filtering
            const imgData = canvas.toDataURL('image/png');

            doc.addImage(imgData, 'PNG', x, y, width, height);
            
            return new Blob([doc.output('arraybuffer')], { type: 'application/pdf' });
        }

        async function convertAndDownload() {
            if (!originalImage) {
                showMessage('error', 'Please load an image before exporting.');
                return;
            }

            convertButton.textContent = 'Processing...';
            convertButton.disabled = true;

            // Ensure the canvas reflects the latest settings
            redrawCanvas();

            const format = outputFormat.value;
            let extension = '';
            let downloadBlob = null; 
            let downloadDataURL = null; 

            try {
                if (format === 'png' || format === 'jpeg') {
                    // Raster Conversions (PNG and JPG)
                    const mimeType = format === 'png' ? 'image/png' : 'image/jpeg';
                    extension = format === 'png' ? 'png' : 'jpg';
                    
                    if (format === 'png') {
                        downloadDataURL = conversionCanvas.toDataURL(mimeType);
                    } else {
                        const quality = parseInt(document.getElementById('jpegQuality').value) / 100;
                        downloadDataURL = conversionCanvas.toDataURL(mimeType, quality);
                    }
                } else if (format === 'svg') {
                    // Vector Conversion (SVG)
                    extension = 'svg';
                    const svgString = rasterToSimpleSVG(conversionCanvas, conversionCanvas.width, conversionCanvas.height);
                    downloadBlob = new Blob([svgString], { type: 'image/svg+xml' });
                } else if (format === 'ico') {
                    // ICO Conversion
                    extension = 'ico';
                    downloadBlob = await convertToICO(conversionCanvas);
                } else if (format === 'pdf') {
                    // PDF Conversion
                    extension = 'pdf';
                    downloadBlob = await convertToPDF(conversionCanvas, originalImage);
                } else {
                    throw new Error('Invalid output format selected.');
                }
            } catch (e) {
                console.error("Conversion Error:", e);
                showMessage('error', `Export failed for ${format.toUpperCase()}. See console.`);
                return;
            } finally {
                convertButton.textContent = 'Export Image';
                convertButton.disabled = false;
            }

            // --- Download Trigger ---
            const link = document.createElement('a');
            // Ensure the filename is based on the original name + "_edited" + extension
            link.download = `${originalFileName}_edited.${extension}`;
            
            if (downloadBlob) {
                // Use blob URL for SVG, ICO, and PDF
                const url = URL.createObjectURL(downloadBlob);
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
            } else if (downloadDataURL) {
                // Use Data URL for PNG and JPG
                link.href = downloadDataURL;
                link.click();
            }

            showMessage('success', `Image successfully exported and download started for ${extension.toUpperCase()}!`);
        }

        convertButton.addEventListener('click', convertAndDownload);
        
        // Default to Adjustments tab on load
        tabs.adjust.click();
    </script>
</body>
</html>